unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, FileUtil, Forms, Controls, Graphics, Dialogs, StdCtrls,
  unit2;

type

  { TForm1 }

  TForm1 = class(TForm)
    Button1: TButton;
    Button2: TButton;
    Button3: TButton;
    Button4: TButton;
    Memo1: TMemo;
    Memo2: TMemo;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
  private

  public

  end;

var
  Form1: TForm1;

  // Делаем матрицу и её размерность глобальными переменными
  // чтобы они были видны во всех функциях -
  // обработчиков нажатия кнопок
  a: Matrix;       // матрица
  n,m : integer; // число строк и столбцов

implementation

{$R *.lfm}

{ TForm1 }

{Процедура добавления ОДНОЙ строки чисел в Memo(Печатаем одномерный массив)}
// row - одномерный массив -СТРОКА МАТРИЦЫ(Поэтому Ar, а не Matrix)
// m - число столбцов
// aMemo - Объект мемо куда записываем строку матрицы(var т.к. изменяем его)
procedure PrintRow(row: Ar; m: integer; var aMemo: TMemo);
var
   // строковое представление одного числа
   s_x: string;
   // Строкое представление одномерного массива row
   // то есть это сумма строковых представлений каждого элемента(s_x)
   // одномерного массива 'row'
   s_row: string;
   j: integer; // для перебора столбцов
begin
  s_row:='';
  for j:=1 to m do
  begin
    // преобразуем ЕЛЕМЕНТ СТРОКИ(одномерного массива) в строку
    // число 5 - так же как и в writeln - ширина поля под число
    // чтобы не замарачиваться с пробелами при выводе
    str(row[j]:5, s_x);
    // по одному элементы Одномерного массива 'row' собираем в одну строку
    s_row := s_row + s_x;
  end;
  // собрали одну строку, теперь добавляем её в Memo
  aMemo.Append(s_row);
end;

{Вывод МАТРИЦЫ в Memo}
// a - наша матрица - двухмерный массив(поэтому тип Matrix, а не Ar)
// n - число строк
// m - число столбцов
// 'var aMemo:TMemo' так как мы будем изменять объект Memo - записывать в него
// Хотя это не обязательно, работает и без, тупо для приличия делаем так
procedure PrintMatrix(a: Matrix; n: integer; m: integer; var aMemo: TMemo);
var
  i: integer;
begin

  // Оюходим все строки Матрицы
  for i:=1 to n do
      // И печатаем каждую строку в переданный объект mem типа TMemo
      PrintRow(a[i], m, aMemo);
end;


// Понадобиться если Преподаватель захочет изменить матрицу в Memo1
// и чтобы эти изменения были отображены в работе программы
// например изменит число в строке - тогда СУММА  эдементов в строке
// ДОЛЖНА ПОМЕНЯТЬСЯ

// Необязательно - по прихоти препода
// Если что раскомментируй - убери вначале '{' и в конце '}'
// Дальше смотри {Нажали 'Обработка'}

{

{Считываем матрицу из Memo}
// 'var' чтобы изменить переменные передавааемые в функцию
// aMemo: TMemo без var т.к. мы только считываем оттуда
procedure InputMatrix(var a: Matrix; var n: integer; var m: integer; aMemo:TMemo);
var i, j: integer;
    c: integer; // номер столбца элемента
    s_x: string; // строковое представление елемента матрицы

begin

  // Чтобы меньше повторяться
  // Так раньше надо было бы писать aMemo.Lines.Count
  // Тперь достаточно писать Lines.Count
  With aMemo do
  begin
    // Перебираем строки из Memo
    for i:=0 to Lines.Count-1 do
    begin
      j :=1;  // Счётчик СИМВОЛОВ в строке
      c := 0; // Счётчик ЭЛЕМЕНТОВ - найденных ЧИСЕЛ
      // Перебираем i-ую строку посимвольно
      while (j <= length(Lines[i])) do
      begin
        // собираем из символов число
        s_x := ''; // cтрока цифр - элемент матрицы в виде строки
        while ((j <= length(Lines[i])) and (Lines[i][j] in ['0' .. '9'])) do
        begin
           s_x := s_x + Lines[i][j];
           j:= j +1;
        end;

        // Нужно сделать проверку
        // Вдруг вначале стояли пробелы и мы даже не начали цикл выше
        // то есть aMemo.Lines[i][j] in ['0' .. '9'] - ЛОЖЬ

        // если строковое представление элемента - НЕ пустая строка
        if (not (s_x = '')) then
        begin
          // Мы смогли собрать число
          // Увеличиваем счётчик элементов в одной строке
          c:= c + 1;
          // И добавляем число в матрицу
          // i+1 - тк строки в Memo нумеруются с 0, а в матрице с 1
          a[i+1, c] := StrToInt(s_x); // нужно привести к целому типу

          // По поводу счётчика елементов 'с' - счётчика чисел в строке
          // мы не можем перебрать элементы из строки в цикле for
          // так как не известно их количество
          // так же мы не можем перебрать элемнты считывая их по одному
          // как в readln т.к. мы имеем только строки и мы должны преобразовать
          // последовательность символов в ЦЕЛОЧИСЛЕННЫЕ элементы матрицы
          // Счётчик элементов 'c' в строке будет увеличиваться каждый раз,
          // когда мы находим(собираем из символом) число в строке
          // и  он будет обнуляться при переходе на новую строку
        end;

        // если мы здесь то дальше какой-то символ - НЕ цифра

        // Перебираем строку до тех пор пока не попадём не цыфру
        // Нам нужны только цыфры, а остальные символы просто пропускаем
        while ((j <= length(Lines[i])) and not (Lines[i][j] in ['0' .. '9'])) do
          j := j + 1;
      end;
    end;
  end;
  // Вышли из with - теперь чтобы обращаться к свойствам объекта aMemo,
  // нужно пользоваться точкой '.' - пример ниже

  // Нужно также задать РАЗМЕРНОСТЬ полученной матрицы
  n:= aMemo.Lines.Count; // число строк = число строк в Memo
  // Число столбцов равно счётчику элементов в одной строке
  // Прричом заметь, что после завершения цикла с - не обнуляется
  // И равен как раз найденному числу элементов в строке
  m:= c;
end;

}

{Нажали 'Закрыть'}
procedure TForm1.Button1Click(Sender: TObject);
begin
  close;
end;

{Нажали 'Новая Матрица'}
procedure TForm1.Button2Click(Sender: TObject);
begin
  // Получаем размерность матрицы от пользователя
  // InputBox возвращает строку, но ГЛОБАЛЬНЫЕ переменные n и m типа integer
  // поэтому преобразуем возвращаем значение в целое число при помощи StrToInt
  n := StrToInt(InputBox('Ввод числа', 'Количестов Строк', '5'));
  m := StrToInt(InputBox('Ввод числа', 'Количество Столбцов', '5'));

  // Теперь так как УЖЕ ЕСТЬ число строк и столбцов
  // Заполняем матрицу
  CreateMatrix(a, n, m);

  // выводим матрицу в Memo1 - исходная матрица
  PrintMatrix(a, n, m, Memo1);

end;

{Нажали 'Обработка'}
procedure TForm1.Button3Click(Sender: TObject);
var i: integer;
    s: integer; // Cумма элементов матрицы в одной строке
    s_s: string; // СТРОКОВОЕ представление СУММЫ строки
    k: integer; // число которое вводит пользователь (Сумма чисел строки БОЛЬШЕ него)
begin

  // Считываем ИСХОДНУЮ матрицу из Memo1
  // Необязательно, смотри определение процедуры, для нужного функционала
  // не забудь раскомментировать здесь тоже
  //InputMatrix(a, n, m, Memo1);

  // Переменные a, n, m - глобальне переменны, которые видны во всех процедурах
  // их значения должны быть УЖЕ ЗАДАНЫ при нажатии кнопки {Новая матрица}

  {Добавляем столбик с суммами элементов каждой строки в Memo1}
  // обходим строки матрицы
  for i:=1 to n do
  begin
    // Находим сумму элементов матрицы в i-ой строке
    SumRow(a[i], m, s);
    // В Мемо можно записать только строки
    // 's:10' - тоже самое, что и
    // при выводе при помощи writeln
    // 10 - сколько отводится места на всё число
    str(s:10, s_s);
    // добавляем к каждой строке в Memo справа - это число
    Memo1.Lines[i-1] := Memo1.Lines[i-1] + s_s;
  end;


   // Получаем число, от польователя, чтобы понять
   // какие строки печатать в Memo2
   // Сумма элементов  этих строк должна быть БОЛЬШЕ этого числа
   k := StrToInt(InputBox('Обработка', 'Введите число', '300'));

   // Делаем это именно после добавления столбца СУММ в Memo1,
   // Чтобы можно было посмотреть Сумму элементов каждой строки
   // и подобрать число K

   // теперь добавляем строки в Memo2
   for i:=1 to n do
   begin
     // Получаем СУММУ элементов для i-ой строки
     SumRow(a[i],m, s);
     // Если Сумма строки БОЛЬШЕ числа K - то это строка должна быть в Memo2
     if (s > k) then
        PrintRow(a[i], m, Memo2);
   end;

end;

{Нажали 'Очистить Поля'}
procedure TForm1.Button4Click(Sender: TObject);
begin
  // Нужно очистить два текстовых поля
  // реализация очистки есть внутри этих объектов
  Memo1.Clear;
  Memo2.Clear;
end;

end.

